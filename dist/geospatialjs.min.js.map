{"version":3,"sources":["BoundingBox.js","GeolocationCode.js","GpxTrack.js","LatLng.js","TrackPoint.js","TrackSegment.js","Util.js"],"names":["GeospatialJS","mod","BoundingBox","self","this","north","ko","observable","east","south","west","setFromLocations","locations","forEach","x","lat","lng","ISO7064Mod11_10Check","GeolocationCode","baseSequence","toBase","decimal","symbols","split","base","length","conversion","Math","floor","parseInt","fromBase","string","digits","number","multiplier","i","digit","indexOf","pad","Array","join","slice","parseCode","code","idWithCheckDigit","replace","id","checkDigit","computeCheck","getCode","plat","plng","parseFloat","isNaN","latInt","lngInt","findCodes","found","reg","matches","exec","push","encode","str","verify","t","c","charCodeAt","f","getCheckDigit","val","getData","substring","GpxTrack","trackXml","getClosestPoint","timestamp","segment","findSegmentByTimestamp","getClosestPointResursive","points","startIdx","endIdx","rec","idx","point","time","maxDelta","delta","abs","_","segments","find","unix","startTime","endTime","getElementsByTagName","map","TrackSegment","LatLng","data","display","ew","ns","format","formatNum","distance","toRad","value","PI","R","dLat","dLon","lat1","lat2","a","sin","cos","atan2","sqrt","d","toDms","deg","md","m","sd","toJS","toDmsFormat","dms","toFixed","displayDms","computed","glatlng","displayDec","latlng","distanceDisplay","dist","gridId","round","geolocatorLink","mapLink","lang","NS","EW","geohackLink","geocodeLink","TrackPoint","xmlNode","index","getAttribute","getNearbyPoint","targetIndex","speed","pointCount","j","bearing","lon1","lon2","y","toBrng","eleNodes","ele","textContent","timeNodes","moment","track","trackpoints","pointIndex","min","max","formatString","args","arguments","match","precision","options","defaultOptions","thousandSeparator","decimalSeparator","opt","$","extend"],"mappings":"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","file":"geospatialjs.min.js","sourcesContent":["/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function(mod) {\n    \"use strict\";\n\n    mod.BoundingBox = function() {\n        var self = this;\n\n        self.north = ko.observable();\n        self.east = ko.observable();\n        self.south = ko.observable();\n        self.west = ko.observable();\n\n        self.setFromLocations = function(locations) {\n\n            self.north = ko.observable(-90);\n            self.east = ko.observable(-180);\n            self.south = ko.observable(90);\n            self.west = ko.observable(180);\n\n            locations.forEach(function(x) {\n                if(x.lat() < self.south()) self.south(x.lat());\n                if(x.lng() < self.west()) self.west(x.lng());\n                if(x.lat() > self.north()) self.north(x.lat());\n                if(x.lng() > self.east()) self.east(x.lng());\n            });\n        };\n    };\n\n})(GeospatialJS);","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function(mod) {\n    \"use strict\";\n\n    mod.GeolocationCode = (function() {\n\n        var baseSequence =  \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n        var toBase = function (decimal) {\n            var symbols = baseSequence.split(\"\");\n            var base = baseSequence.length;\n            var conversion = \"\";\n\n            if (base > symbols.length || base <= 1) {\n                return false;\n            }\n\n            while (decimal >= 1) {\n                conversion = symbols[(decimal - (base * Math.floor(decimal / base)))] + \n                             conversion;\n                decimal = Math.floor(decimal / base);\n            }\n\n            return (base < 11) ? parseInt(conversion, 10) : conversion;\n        };\n\n        var fromBase = function(string) {\n            var symbols = baseSequence.split(\"\");\n            var base = baseSequence.length;\n\n            var digits = string.split(\"\");\n            var number = 0;\n            var multiplier = 1;\n\n            for(var i = digits.length-1; i >=0; i--) {\n                var digit = digits[i];\n\n                number += symbols.indexOf(digit) * multiplier;\n                multiplier = multiplier*base;\n            }\n\n            return number;\n        };\n\n        var pad = function(string, length) {\n          if (string.length < length) { \n            string = (new Array(length).join(\"0\")+string).slice(-length); \n          }\n          return string;\n        };\n\n        var parseCode =  function(code) {\n            var idWithCheckDigit = fromBase(code.replace(/^GEO/, ''));\n            var id = parseInt((\"\"+idWithCheckDigit).replace(/[_0-9]$/, ''), 10);\n            var checkDigit = idWithCheckDigit % 10;\n            var isValid = ISO7064Mod11_10Check.computeCheck(\"\"+id) == checkDigit;\n            var lat = Math.floor(id/10000000)/10000-90;\n            var lng = id%10000000/10000-180;\n            return [ lat, lng ];\n        };\n\n        return {\n            getCode: function(plat, plng) {\n                var lat = parseFloat(plat);\n                var lng = parseFloat(plng);\n\n                if(isNaN(lat) || isNaN(lng) || plat < -90 || plat > 90 || plng < -180 || plng > 180) return \"\";\n                var latInt = Math.floor((parseFloat(plat)+90)*10000);\n                var lngInt = Math.floor((parseFloat(plng)+180)*10000);\n\n                var id = lngInt + latInt * 10000000;\n                var checkDigit = ISO7064Mod11_10Check.computeCheck(\"\"+id);\n                var idWithCheckDigit = id * 10 + checkDigit;\n                return \"GEO\"+pad(toBase(idWithCheckDigit), 8);\n            },\n\n            parseCode: parseCode,\n\n            findCodes: function(string) {\n\n                var reg = /GEO[a-zA-Z0-9]{8}/g;\n                var matches = [], found;\n                while ((found = reg.exec(string))) {\n                    matches.push(parseCode(found[0]));\n                    //reg.lastIndex -= found[0].split(':')[1].length;\n                }\n                return matches;\n            }\n        };\n    }());\n\n    /* 3rd party code */\n\n    /* CheckISO7064Mod11_1.js  Version 1.0.0  24-Jun-05\n     * http://modp.com/release/checkdigits/\n     * Copyright 2005, Nick Galbreath.  All Rights Reserved.\n     * Terms of use: standard BSD License at http://modp.com/license-bsd.txt\n     * or http://www.opensource.org/licenses/bsd-license.php\n     */\n\n    function ISO7064Mod11_10Check() {}\n\n    ISO7064Mod11_10Check.encode = function (str) {\n      return str + this.computeCheck(str);\n    };\n\n    ISO7064Mod11_10Check.verify = function (str) {\n      var t = 10;\n      for (var i = 0; i < str.length -1; ++i) {\n        var c = str.charCodeAt(i) - 48;\n        if (c < 0 || c > 9) return false;\n        t = (2 * this.f(t+c)) % 11;\n      }\n      return (((t + this.getCheckDigit(str)) % 10) == 1);\n    };\n\n    /**\n     * \"private\" helper function\n     */\n    ISO7064Mod11_10Check.f = function (x) {\n      var val = x % 10;\n      return (val === 0) ? 10 : val;\n    };\n\n    ISO7064Mod11_10Check.computeCheck = function (str) {\n      var t = 10;\n      for (var i = 0; i < str.length; ++i) {\n        t = (2 * this.f(t + str.charCodeAt(i) - 48)) % 11;\n      }\n      return (11 - t) % 10;\n    };\n\n    ISO7064Mod11_10Check.getCheckDigit = function (str) {\n      return str.charCodeAt(str.length - 1) - 48;\n    };\n\n    ISO7064Mod11_10Check.getData = function (str) {\n      return str.substring(0, str.length - 1);\n    };\n\n})(GeospatialJS);","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function (mod) {\n    \"use strict\";\n\n    mod.GpxTrack = function(trackXml) {\n        var self = this;\n\n        self.getClosestPoint = function(timestamp) {\n\n            var segment = self.findSegmentByTimestamp(timestamp);\n            if(!segment) return null;\n\n            return self.getClosestPointResursive(timestamp, segment, 0, segment.points.length-1, 0);\n        };\n\n        self.getClosestPointResursive = function(timestamp, segment, startIdx, endIdx, rec) {\n            \n            if(rec > 10) return null; \n            var idx = startIdx + Math.floor((endIdx - startIdx)/2);\n            var point = segment.points[idx];\n        \n            if(endIdx-startIdx < 4 || point.time == timestamp) \n            {\n                var maxDelta = 1000000000;\n                for(var i = startIdx; i <= endIdx; i++)\n                {\n                    var delta = Math.abs(timestamp - segment.points[i].time);\n                    if(delta < maxDelta)\n                    {\n                        point = segment.points[i];\n                        maxDelta = delta;\n                    }\n                }\n                return point;\n            }\n            \n            if(point.time > timestamp)\n            {\n                return self.getClosestPointResursive(timestamp, segment, startIdx, idx, rec+1);\n            }\n            else\n            {\n                return self.getClosestPointResursive(timestamp, segment, idx, endIdx, rec+1);\n            }\n        };\n\n        self.findSegmentByTimestamp = function(timestamp) {\n            if(!timestamp) return null;\n            return _(self.segments).find(function(segment) {\n                return timestamp.unix() >= segment.startTime.unix() && timestamp.unix() <= segment.endTime.unix();\n            });\n        };\n\n        self.startTime = function() { \n            var self = this;\n\n            return self.segments.length > 0 ? \n                self.segments[0].startTime\n                : null;\n        }; \n\n        self.endTime = function() { \n            var self = this;\n\n            return self.segments.length > 0 ? \n                self.segments[self.segments.length-1].endTime\n                : null;\n        }; \n\n        //-- init\n\n        var idx = 0;\n        self.segments = _(trackXml.getElementsByTagName(\"trkseg\")).map(function(x) { \n            return new mod.TrackSegment(x, idx++, self); \n        });\n\n\n    };\n}(GeospatialJS));\n\n","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function(mod) {\n    \"use strict\";\n\n    mod.LatLng = function(data)\n    {\n        var self = this;\n\n        if(data instanceof Array) {\n            if(data.length != 2) {\n                throw \"Array with two elements expected\";\n            }\n            if(typeof data[0] !== \"number\" || typeof data[1] !== \"number\") {\n                throw \"Float values expected\";\n            }\n\n            self.lat = ko.observable(data[0]);\n            self.lng = ko.observable(data[1]);\n        }\n        else if(data && data.lat && data.lng)\n        {\n            if(typeof data.lat !== \"number\" || typeof data.lng !== \"number\") {\n                throw \"Float values expected\";\n            }\n            self.lat = ko.observable(data.lat);\n            self.lng = ko.observable(data.lng); \n        }\n        else\n        {\n            self.lat = ko.observable(0);\n            self.lng = ko.observable(0);    \n        }\n\n\n        self.display = function()\n        {\n            var ew = self.lng() < 0 ? \"W\" : \"E\";\n            var ns = self.lat() < 0 ? \"S\" : \"N\";\n            \n            return mod.format(\"{0}\\u00a0{1} {2}\\u00a0{3}\", \n                Math.abs(mod.formatNum(self.lat(), 4)), \n                ns, \n                Math.abs(mod.formatNum(self.lng(), 4)),\n                ew\n            );\n        };\n\n        self.distance = function(point)\n        {\n            var toRad = function(value) { return value * Math.PI / 180; };\n            \n            if(!(point instanceof mod.LatLng))\n                throw \"GeospatialJS.LatLng object expected\";\n            \n            var R = 6371; // km\n            var dLat = toRad((point.lat()-this.lat()));\n            var dLon = toRad((point.lng()-this.lng()));\n            var lat1 = toRad(this.lat());\n            var lat2 = toRad(point.lat());\n            \n            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n                    Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); \n            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n            var d = R * c;\n            return d;\n        };\n\n        self.toDms = function(deg) {\n            var d = parseInt(deg, 10);\n            var md = Math.abs(deg-d) * 60;\n            var m = parseInt(md, 10);\n            var sd = (md - m) * 60;\n            return [d, m, sd];\n        };\n\n        self.toJS = function() {\n            return { lat: self.lat(), lng: self.lng() };\n        };\n\n        self.toDmsFormat =  function(deg) {\n            var dms = self.toDms(deg);\n            return GeospatialJS.format(\"{0}\\xB0 {1}\\u2032 {2}\\u2033\", Math.abs(dms[0]), dms[1], dms[2].toFixed(2) );\n        };\n\n        self.displayDms = ko.computed(function(glatlng)\n        {\n            var ew = self.lng() < 0 ? \"W\" : \"E\";\n            var ns = self.lat() < 0 ? \"S\" : \"N\";\n            \n            return GeospatialJS.format(\"{0} {1} {2} {3}\", \n                self.toDmsFormat(self.lat()),\n                ns, \n                self.toDmsFormat(self.lng()),\n                ew\n            );\n        });\n\n        self.displayDec = ko.computed(function(glatlng)\n        {\n            return self.display();\n        });\n\n        self.latlng = ko.computed(function() {\n            return { lat: self.lat(), lng: self.lng() };\n        });\n\n        self.str = function(glatlng)\n        {\n            return \"\" + self.lat()  + \",\" + self.lng();\n        };\n\n        self.distanceDisplay = function(point)\n        {\n            var dist = this.distance(point);\n            return (dist >= 1) ?  GeospatialJS.format(\"{0} {1}\", GeospatialJS.formatNum(dist, 1), \"km\")\n                : GeospatialJS.format(\"{0} {1}\", GeospatialJS.formatNum(dist*1000), \"m\");\n        };\n\n        self.gridId = function() {\n            return Math.round((90*100+Math.floor(self.lat()*100))*100000 + 180*100+Math.floor(self.lng()*100));\n        };\n\n        self.geolocatorLink = function()\n        {\n            return GeospatialJS.format(\"http://tools.freeside.sk/geolocator/geolocator.html?q={0},{1}\",\n                self.lat(), self.lng()\n            );  \n        };\n\n        self.mapLink = function(lang)\n        {\n            return GeospatialJS.format(\"/map/{0},{1}/15/{2}\", (\"\"+self.lat()).replace(\",\", \".\") , (\"\"+self.lng()).replace(\",\", \".\"), lang ? lang : \"en\");\n        };\n\n        self.NS = function() {\n            return self.lat() >= 0 ? \"N\" : \"S\";\n        };\n\n        self.EW = function() {\n            return self.lng() >= 0 ? \"E\" : \"W\";\n        };\n\n        self.geohackLink = function()\n        {\n            return GeospatialJS.format(\"http://toolserver.org/~geohack/geohack.php?params={0}_{1}_{2}_{3}\",\n                Math.abs(self.lat()), self.NS(), Math.abs(self.lng()), self.EW()\n            );  \n        };\n\n        self.geocodeLink = ko.computed(function() {\n             return GeospatialJS.format(\"https://geolocation.ws/{0}\", mod.GeolocationCode.getCode(self.lat(),self.lng()));\n        });\n    };\n})(GeospatialJS);","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function (mod) {\n    \"use strict\";\n\n    mod.TrackPoint = function(xmlNode, index, segment) {\n        var self = this;\n\n        self.index = index;\n        self.segment = segment;\n        self.lat = parseFloat(xmlNode.getAttribute(\"lat\"));\n        self.lng = parseFloat(xmlNode.getAttribute(\"lon\"));\n\n        self.getNearbyPoint = function(index) {\n            var targetIndex = self.index + index;\n            if(targetIndex < 0 || targetIndex > self.segment.points.length-1)\n                return null;\n            return self.segment.points[targetIndex];\n        };\n\n        self.distance = function(point)\n        {\n            var toRad = function(value) { return value * Math.PI / 180; };\n            \n            var R = 6371; // km\n            var dLat = toRad((point.lat-this.lat));\n            var dLon = toRad((point.lng-this.lng));\n            var lat1 = toRad(this.lat);\n            var lat2 = toRad(point.lat);\n            \n            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n                    Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); \n            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n            var d = R * c;\n            return d;\n        };\n\n        self.speed = function() {\n            var pointCount = 10;\n            var distance = 0;\n\n            var points = [];\n            for(var i=-1; i>=-pointCount; i--) {\n                var point = self.getNearbyPoint(i);\n                if(!point) break;\n                points.push(point);                \n            }\n\n            if(points.length === 0) return null;\n            var time = self.time.unix() - points[points.length-1].time.unix();\n            for(var j=0; j<points.length; j++) {\n                distance += points[j].distance(j === 0 ? self : points[j-1]);\n            }\n\n            return distance/(time/3600); // km/h\n            \n        };\n\n        self.bearing = function() {\n            var point = self.getNearbyPoint(-1);\n\n            var lat1 = self.lat;\n            var lon1 = self.lng;\n            var lat2 = point.lat;\n            var lon2 = point.lng;\n\n            lat1 = lat1.toRad(); lat2 = lat2.toRad();\n            var dLon = (lon2-lon1).toRad();\n\n            var y = Math.sin(dLon) * Math.cos(lat2);\n            var x = Math.cos(lat1)*Math.sin(lat2) -\n                  Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);\n            \n            return Math.atan2(y, x).toBrng();\n        };\n\n        var eleNodes = xmlNode.getElementsByTagName(\"ele\");\n        if(eleNodes.length > 0)\n        {\n            self.ele = parseFloat(eleNodes[0].textContent);\n        }\n\n        var timeNodes = xmlNode.getElementsByTagName(\"time\");\n        if(timeNodes.length > 0)\n        {\n            self.time = moment(timeNodes[0].textContent);\n        }\n    };\n\n}(GeospatialJS));\n","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function (mod) {\n    \"use strict\";\n\n    mod.TrackSegment = function(xmlNode, index, track) {\n        var self = this;\n\n        var trackpoints = xmlNode.getElementsByTagName(\"trkpt\");\n        \n        var pointIndex = 0;\n        \n        self.points = _(trackpoints).map(function(x) { \n            return new mod.TrackPoint(x, pointIndex++, self); \n        });\n\n        self.index = index; \n        self.startTime = _(self.points).min(function(x) { return x.time.unix(); }).time;\n        self.endTime = _(self.points).max(function(x) { return x.time.unix(); }).time;\n    };   \n}(GeospatialJS));\n\n","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS = GeospatialJS || {};\n\nGeospatialJS.format = function(formatString) {\n    var args = arguments;\n\n    return formatString.replace(/{(\\d+)}/g, function (match, number) {\n        var idx = parseInt(number, 10)+1;\n        return typeof args[idx] != 'undefined' ? args[idx] : match;\n    });\n};\n\nGeospatialJS.formatNum = function(value, precision, options) {\n    if(!value)\n        return null;\n    var defaultOptions = { \n        \"thousandSeparator\": \",\",\n        \"decimalSeparator\": \".\"\n    };\n\n    var opt = $.extend({}, defaultOptions, options);\n    var f = \"\";\n    \n    if(precision && precision > 0)\n        f = opt.decimalSeparator + value.toFixed(precision).slice(-precision); \n    \n    return value.toFixed(2).slice(0,-3).replace(/(?=(?!^)(?:\\d{3})+(?!\\d))/g, opt.thousandSeparator) + f;\n};"],"sourceRoot":"/source/"}