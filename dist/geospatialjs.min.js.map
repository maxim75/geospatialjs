{"version":3,"sources":["BoundingBox.js","GeolocationCode.js","GpxTrack.js","LatLng.js","Util.js"],"names":["GeospatialJS","mod","BoundingBox","self","this","north","ko","observable","east","south","west","setFromLocations","locations","forEach","x","lat","lng","ISO7064Mod11_10Check","GeolocationCode","baseSequence","toBase","decimal","symbols","split","base","length","conversion","Math","floor","parseInt","fromBase","string","digits","number","multiplier","i","digit","indexOf","pad","Array","join","slice","parseCode","code","idWithCheckDigit","replace","id","checkDigit","computeCheck","getCode","plat","plng","parseFloat","isNaN","latInt","lngInt","findCodes","found","reg","matches","exec","push","encode","str","verify","t","c","charCodeAt","f","getCheckDigit","val","getData","substring","TrackPoint","xmlNode","index","segment","getAttribute","getNearbyPoint","targetIndex","points","distance","point","toRad","value","PI","R","dLat","dLon","lat1","lat2","a","sin","cos","atan2","sqrt","d","speed","pointCount","time","unix","j","bearing","lon1","lon2","y","toBrng","eleNodes","getElementsByTagName","ele","textContent","timeNodes","moment","TrackSegment","track","trackpoints","pointIndex","_","map","startTime","min","endTime","max","GpxTrack","trackXml","getClosestPoint","timestamp","findSegmentByTimestamp","getClosestPointResursive","startIdx","endIdx","rec","idx","maxDelta","delta","abs","segments","find","LatLng","data","display","ew","ns","format","formatNum","toDms","deg","md","m","sd","toJS","toDmsFormat","dms","toFixed","displayDms","computed","glatlng","displayDec","latlng","distanceDisplay","dist","gridId","round","geolocatorLink","mapLink","lang","NS","EW","geohackLink","geocodeLink","formatString","args","arguments","match","precision","options","defaultOptions","thousandSeparator","decimalSeparator","opt","$","extend"],"mappings":"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","file":"geospatialjs.min.js","sourcesContent":["/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function(mod) {\n    \"use strict\";\n\n    mod.BoundingBox = function() {\n        var self = this;\n\n        self.north = ko.observable();\n        self.east = ko.observable();\n        self.south = ko.observable();\n        self.west = ko.observable();\n\n        self.setFromLocations = function(locations) {\n\n            self.north = ko.observable(-90);\n            self.east = ko.observable(-180);\n            self.south = ko.observable(90);\n            self.west = ko.observable(180);\n\n            locations.forEach(function(x) {\n                if(x.lat() < self.south()) self.south(x.lat());\n                if(x.lng() < self.west()) self.west(x.lng());\n                if(x.lat() > self.north()) self.north(x.lat());\n                if(x.lng() > self.east()) self.east(x.lng());\n            });\n        };\n    };\n\n})(GeospatialJS);","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function(mod) {\n    \"use strict\";\n\n    mod.GeolocationCode = (function() {\n\n        var baseSequence =  \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n        var toBase = function (decimal) {\n            var symbols = baseSequence.split(\"\");\n            var base = baseSequence.length;\n            var conversion = \"\";\n\n            if (base > symbols.length || base <= 1) {\n                return false;\n            }\n\n            while (decimal >= 1) {\n                conversion = symbols[(decimal - (base * Math.floor(decimal / base)))] + \n                             conversion;\n                decimal = Math.floor(decimal / base);\n            }\n\n            return (base < 11) ? parseInt(conversion, 10) : conversion;\n        };\n\n        var fromBase = function(string) {\n            var symbols = baseSequence.split(\"\");\n            var base = baseSequence.length;\n\n            var digits = string.split(\"\");\n            var number = 0;\n            var multiplier = 1;\n\n            for(var i = digits.length-1; i >=0; i--) {\n                var digit = digits[i];\n\n                number += symbols.indexOf(digit) * multiplier;\n                multiplier = multiplier*base;\n            }\n\n            return number;\n        };\n\n        var pad = function(string, length) {\n          if (string.length < length) { \n            string = (new Array(length).join(\"0\")+string).slice(-length); \n          }\n          return string;\n        };\n\n        var parseCode =  function(code) {\n            var idWithCheckDigit = fromBase(code.replace(/^GEO/, ''));\n            var id = parseInt((\"\"+idWithCheckDigit).replace(/[_0-9]$/, ''), 10);\n            var checkDigit = idWithCheckDigit % 10;\n            var isValid = ISO7064Mod11_10Check.computeCheck(\"\"+id) == checkDigit;\n            var lat = Math.floor(id/10000000)/10000-90;\n            var lng = id%10000000/10000-180;\n            return [ lat, lng ];\n        };\n\n        return {\n            getCode: function(plat, plng) {\n                var lat = parseFloat(plat);\n                var lng = parseFloat(plng);\n\n                if(isNaN(lat) || isNaN(lng) || plat < -90 || plat > 90 || plng < -180 || plng > 180) return \"\";\n                var latInt = Math.floor((parseFloat(plat)+90)*10000);\n                var lngInt = Math.floor((parseFloat(plng)+180)*10000);\n\n                var id = lngInt + latInt * 10000000;\n                var checkDigit = ISO7064Mod11_10Check.computeCheck(\"\"+id);\n                var idWithCheckDigit = id * 10 + checkDigit;\n                return \"GEO\"+pad(toBase(idWithCheckDigit), 8);\n            },\n\n            parseCode: parseCode,\n\n            findCodes: function(string) {\n\n                var reg = /GEO[a-zA-Z0-9]{8}/g;\n                var matches = [], found;\n                while ((found = reg.exec(string))) {\n                    matches.push(parseCode(found[0]));\n                    //reg.lastIndex -= found[0].split(':')[1].length;\n                }\n                return matches;\n            }\n        };\n    }());\n\n    /* 3rd party code */\n\n    /* CheckISO7064Mod11_1.js  Version 1.0.0  24-Jun-05\n     * http://modp.com/release/checkdigits/\n     * Copyright 2005, Nick Galbreath.  All Rights Reserved.\n     * Terms of use: standard BSD License at http://modp.com/license-bsd.txt\n     * or http://www.opensource.org/licenses/bsd-license.php\n     */\n\n    function ISO7064Mod11_10Check() {}\n\n    ISO7064Mod11_10Check.encode = function (str) {\n      return str + this.computeCheck(str);\n    };\n\n    ISO7064Mod11_10Check.verify = function (str) {\n      var t = 10;\n      for (var i = 0; i < str.length -1; ++i) {\n        var c = str.charCodeAt(i) - 48;\n        if (c < 0 || c > 9) return false;\n        t = (2 * this.f(t+c)) % 11;\n      }\n      return (((t + this.getCheckDigit(str)) % 10) == 1);\n    };\n\n    /**\n     * \"private\" helper function\n     */\n    ISO7064Mod11_10Check.f = function (x) {\n      var val = x % 10;\n      return (val === 0) ? 10 : val;\n    };\n\n    ISO7064Mod11_10Check.computeCheck = function (str) {\n      var t = 10;\n      for (var i = 0; i < str.length; ++i) {\n        t = (2 * this.f(t + str.charCodeAt(i) - 48)) % 11;\n      }\n      return (11 - t) % 10;\n    };\n\n    ISO7064Mod11_10Check.getCheckDigit = function (str) {\n      return str.charCodeAt(str.length - 1) - 48;\n    };\n\n    ISO7064Mod11_10Check.getData = function (str) {\n      return str.substring(0, str.length - 1);\n    };\n\n})(GeospatialJS);","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function (mod) {\n    \"use strict\";\n\n    mod.TrackPoint = function(xmlNode, index, segment) {\n        var self = this;\n\n        self.index = index;\n        self.segment = segment;\n        self.lat = parseFloat(xmlNode.getAttribute(\"lat\"));\n        self.lng = parseFloat(xmlNode.getAttribute(\"lon\"));\n\n        self.getNearbyPoint = function(index) {\n            var targetIndex = self.index + index;\n            if(targetIndex < 0 || targetIndex > self.segment.points.length-1)\n                return null;\n            return self.segment.points[targetIndex];\n        };\n\n        self.distance = function(point)\n        {\n            var toRad = function(value) { return value * Math.PI / 180; };\n            \n            var R = 6371; // km\n            var dLat = toRad((point.lat-this.lat));\n            var dLon = toRad((point.lng-this.lng));\n            var lat1 = toRad(this.lat);\n            var lat2 = toRad(point.lat);\n            \n            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n                    Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); \n            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n            var d = R * c;\n            return d;\n        };\n\n        self.speed = function() {\n            var pointCount = 10;\n            var distance = 0;\n\n            var points = [];\n            for(var i=-1; i>=-pointCount; i--) {\n                var point = self.getNearbyPoint(i);\n                if(!point) break;\n                points.push(point);                \n            }\n\n            if(points.length === 0) return null;\n            var time = self.time.unix() - points[points.length-1].time.unix();\n            for(var j=0; j<points.length; j++) {\n                distance += points[j].distance(j === 0 ? self : points[j-1]);\n            }\n\n            return distance/(time/3600); // km/h\n            \n        };\n\n        self.bearing = function() {\n            var point = self.getNearbyPoint(-1);\n\n            var lat1 = self.lat;\n            var lon1 = self.lng;\n            var lat2 = point.lat;\n            var lon2 = point.lng;\n\n            lat1 = lat1.toRad(); lat2 = lat2.toRad();\n            var dLon = (lon2-lon1).toRad();\n\n            var y = Math.sin(dLon) * Math.cos(lat2);\n            var x = Math.cos(lat1)*Math.sin(lat2) -\n                  Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);\n            \n            return Math.atan2(y, x).toBrng();\n        };\n\n        var eleNodes = xmlNode.getElementsByTagName(\"ele\");\n        if(eleNodes.length > 0)\n        {\n            self.ele = parseFloat(eleNodes[0].textContent);\n        }\n\n        var timeNodes = xmlNode.getElementsByTagName(\"time\");\n        if(timeNodes.length > 0)\n        {\n            self.time = moment(timeNodes[0].textContent);\n        }\n    };\n\n    mod.TrackSegment = function(xmlNode, index, track) {\n        var self = this;\n\n        var trackpoints = xmlNode.getElementsByTagName(\"trkpt\");\n        \n        var pointIndex = 0;\n        self.points = _(trackpoints).map(function(x) { \n            return new mod.TrackPoint(x, pointIndex++, self); \n        });\n\n        self.index = index; \n        self.startTime = _(self.points).min(function(x) { return x.time.unix(); }).time;\n        self.endTime = _(self.points).max(function(x) { return x.time.unix(); }).time;\n    };\n\n    mod.GpxTrack = function(trackXml) {\n        var self = this;\n\n        self.getClosestPoint = function(timestamp) {\n\n            var segment = self.findSegmentByTimestamp(timestamp);\n            if(!segment) return null;\n\n            return self.getClosestPointResursive(timestamp, segment, 0, segment.points.length-1, 0);\n        };\n\n        self.getClosestPointResursive = function(timestamp, segment, startIdx, endIdx, rec) {\n            \n            if(rec > 10) return null; \n            var idx = startIdx + Math.floor((endIdx - startIdx)/2);\n            var point = segment.points[idx];\n        \n            if(endIdx-startIdx < 4 || point.time == timestamp) \n            {\n                var maxDelta = 1000000000;\n                for(var i = startIdx; i <= endIdx; i++)\n                {\n                    var delta = Math.abs(timestamp - segment.points[i].time);\n                    if(delta < maxDelta)\n                    {\n                        point = segment.points[i];\n                        maxDelta = delta;\n                    }\n                }\n                return point;\n            }\n            \n            if(point.time > timestamp)\n            {\n                return self.getClosestPointResursive(timestamp, segment, startIdx, idx, rec+1);\n            }\n            else\n            {\n                return self.getClosestPointResursive(timestamp, segment, idx, endIdx, rec+1);\n            }\n        };\n\n        self.findSegmentByTimestamp = function(timestamp) {\n            if(!timestamp) return null;\n            return _(self.segments).find(function(segment) {\n                return timestamp.unix() >= segment.startTime.unix() && timestamp.unix() <= segment.endTime.unix();\n            });\n        };\n\n        //-- init\n\n        var idx = 0;\n        self.segments = _(trackXml.getElementsByTagName(\"trkseg\")).map(function(x) { \n            return new mod.TrackSegment(x, idx++, self); \n        });\n    };\n}(GeospatialJS));\n\n","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS;\nGeospatialJS = GeospatialJS || {};\n\n(function(mod) {\n    \"use strict\";\n\n    mod.LatLng = function(data)\n    {\n        var self = this;\n\n        if(data instanceof Array) {\n            if(data.length != 2) {\n                throw \"Array with two elements expected\";\n            }\n            if(typeof data[0] !== \"number\" || typeof data[1] !== \"number\") {\n                throw \"Float values expected\";\n            }\n\n            self.lat = ko.observable(data[0]);\n            self.lng = ko.observable(data[1]);\n        }\n        else if(data && data.lat && data.lng)\n        {\n            if(typeof data.lat !== \"number\" || typeof data.lng !== \"number\") {\n                throw \"Float values expected\";\n            }\n            self.lat = ko.observable(data.lat);\n            self.lng = ko.observable(data.lng); \n        }\n        else\n        {\n            self.lat = ko.observable(0);\n            self.lng = ko.observable(0);    \n        }\n\n\n        self.display = function()\n        {\n            var ew = self.lng() < 0 ? \"W\" : \"E\";\n            var ns = self.lat() < 0 ? \"S\" : \"N\";\n            \n            return mod.format(\"{0}\\u00a0{1} {2}\\u00a0{3}\", \n                Math.abs(mod.formatNum(self.lat(), 4)), \n                ns, \n                Math.abs(mod.formatNum(self.lng(), 4)),\n                ew\n            );\n        };\n\n        self.distance = function(point)\n        {\n            var toRad = function(value) { return value * Math.PI / 180; };\n            \n            if(!(point instanceof mod.LatLng))\n                throw \"GeospatialJS.LatLng object expected\";\n            \n            var R = 6371; // km\n            var dLat = toRad((point.lat()-this.lat()));\n            var dLon = toRad((point.lng()-this.lng()));\n            var lat1 = toRad(this.lat());\n            var lat2 = toRad(point.lat());\n            \n            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n                    Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); \n            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n            var d = R * c;\n            return d;\n        };\n\n        self.toDms = function(deg) {\n            var d = parseInt(deg, 10);\n            var md = Math.abs(deg-d) * 60;\n            var m = parseInt(md, 10);\n            var sd = (md - m) * 60;\n            return [d, m, sd];\n        };\n\n        self.toJS = function() {\n            return { lat: self.lat(), lng: self.lng() };\n        };\n\n        self.toDmsFormat =  function(deg) {\n            var dms = self.toDms(deg);\n            return GeospatialJS.format(\"{0}\\xB0 {1}\\u2032 {2}\\u2033\", Math.abs(dms[0]), dms[1], dms[2].toFixed(2) );\n        };\n\n        self.displayDms = ko.computed(function(glatlng)\n        {\n            var ew = self.lng() < 0 ? \"W\" : \"E\";\n            var ns = self.lat() < 0 ? \"S\" : \"N\";\n            \n            return GeospatialJS.format(\"{0} {1} {2} {3}\", \n                self.toDmsFormat(self.lat()),\n                ns, \n                self.toDmsFormat(self.lng()),\n                ew\n            );\n        });\n\n        self.displayDec = ko.computed(function(glatlng)\n        {\n            return self.display();\n        });\n\n        self.latlng = ko.computed(function() {\n            return { lat: self.lat(), lng: self.lng() };\n        });\n\n        self.str = function(glatlng)\n        {\n            return \"\" + self.lat()  + \",\" + self.lng();\n        };\n\n        self.distanceDisplay = function(point)\n        {\n            var dist = this.distance(point);\n            return (dist >= 1) ?  GeospatialJS.format(\"{0} {1}\", GeospatialJS.formatNum(dist, 1), \"km\")\n                : GeospatialJS.format(\"{0} {1}\", GeospatialJS.formatNum(dist*1000), \"m\");\n        };\n\n        self.gridId = function() {\n            return Math.round((90*100+Math.floor(self.lat()*100))*100000 + 180*100+Math.floor(self.lng()*100));\n        };\n\n        self.geolocatorLink = function()\n        {\n            return GeospatialJS.format(\"http://tools.freeside.sk/geolocator/geolocator.html?q={0},{1}\",\n                self.lat(), self.lng()\n            );  \n        };\n\n        self.mapLink = function(lang)\n        {\n            return GeospatialJS.format(\"/map/{0},{1}/15/{2}\", (\"\"+self.lat()).replace(\",\", \".\") , (\"\"+self.lng()).replace(\",\", \".\"), lang ? lang : \"en\");\n        };\n\n        self.NS = function() {\n            return self.lat() >= 0 ? \"N\" : \"S\";\n        };\n\n        self.EW = function() {\n            return self.lng() >= 0 ? \"E\" : \"W\";\n        };\n\n        self.geohackLink = function()\n        {\n            return GeospatialJS.format(\"http://toolserver.org/~geohack/geohack.php?params={0}_{1}_{2}_{3}\",\n                Math.abs(self.lat()), self.NS(), Math.abs(self.lng()), self.EW()\n            );  \n        };\n\n        self.geocodeLink = ko.computed(function() {\n             return GeospatialJS.format(\"https://geolocation.ws/{0}\", mod.GeolocationCode.getCode(self.lat(),self.lng()));\n        });\n    };\n})(GeospatialJS);","/* \n * Copyright (C) 2015 Maksym Kozlenko <max@kozlenko.info>\n *\n * This software may be modified and distributed under the terms\n * of the MIT license.  See the LICENSE file for details.\n */\n\nvar GeospatialJS = GeospatialJS || {};\n\nGeospatialJS.format = function(formatString) {\n    var args = arguments;\n\n    return formatString.replace(/{(\\d+)}/g, function (match, number) {\n        var idx = parseInt(number, 10)+1;\n        return typeof args[idx] != 'undefined' ? args[idx] : match;\n    });\n};\n\nGeospatialJS.formatNum = function(value, precision, options) {\n    if(!value)\n        return null;\n    var defaultOptions = { \n        \"thousandSeparator\": \",\",\n        \"decimalSeparator\": \".\"\n    };\n\n    var opt = $.extend({}, defaultOptions, options);\n    var f = \"\";\n    \n    if(precision && precision > 0)\n        f = opt.decimalSeparator + value.toFixed(precision).slice(-precision); \n    \n    return value.toFixed(2).slice(0,-3).replace(/(?=(?!^)(?:\\d{3})+(?!\\d))/g, opt.thousandSeparator) + f;\n};"],"sourceRoot":"/source/"}